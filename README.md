# copb

A functional composition framework built for typescript that provides type
safety without the need for the usual countless overloads, thanks to some
functional type trickery.

This module contains just 4 curried functions: `c`, `o`, `p`, `b`.

## The functions

### `b`

`b` is a simple curried **b**inary composition function, which the other
functions use under the hood.

```ts
import { b } from "https://deno.land/x/copb/mod.ts";

const f = (x: number) => x / 4;
const g = (x: number) => x - 5;

// h = f ∘ g
const h = b(f)(g);

console.log(h(13)); // -> 2
```

### `c`

`c` for **c**allable is used to fold compositional stacks generated by `o` and
`p`. Once folded, the resultant composed function can be applied in the normal
way. See usage in the sections below.

### `o`

`o` (named after the mathematical composition symbol) is for more complex
compositions, with the ability to compose any number of uniary functions
together.

```ts
import { b } from "https://deno.land/x/copb/mod.ts";

const f = (x: string) => "number " + x;
const g = (x: number) => String(x);
const h = (x: number) => x / 3;
const l = (x: number) => x - 6;

// m = f ∘ g ∘ h ∘ l
const m = c(o(f)(g)(h)(l));

console.log(m(15)); // -> "number 3"
```

### `p`

`p` for **pipe** is used to pipe the results of functions to each other. It is
identical to `o` except it is read from left to right.

```ts
import { b } from "https://deno.land/x/copb/mod.ts";

const f = (x: string) => "number " + x;
const g = (x: number) => String(x);
const h = (x: number) => x / 3;
const l = (x: number) => x - 6;

// m = f ∘ g ∘ h ∘ l
const m = c(p(l)(h)(g)(f));

console.log(m(15)); // -> "number 3"
```

## Usage notes

Applying a layer of abstraction, you can think of the `o` and `p` functions as
having _nodes_ within the compositional stack. Each of these nodes is denoted in
a seperate set of brackets.

```ts
c(o(node1)(node2)(node3));
```

When necessary, type annotations can be placed between nodes. For `o`, each
annotation somewhat counterintuitively represents the input type of the
following node, and the second annotation of the first node represents the final
result.

```ts
const m = c(o<string, string>(f)<number>(g)<number>(h)<number>(l));
```

For `p`, each annotation represents the output type of the followind node, and
the second annotation of the first node represents the final input.

```ts
const m = c(p<number, number>(l)<number>(h)<string>(g)<string>(f));
```

## API

Generated API documentation, with pseudohaskell illustrations of type
signatures, is available
[here](https://doc.deno.land/https/deno.land/x/copb/mod.ts).

## Comments

### Intellisense

Your IDE will probably show a disgusting, monstrosity of a type signature.
That's because this project uses recursive types in order to provide robust type
safety. Type checking is still completely functional.
